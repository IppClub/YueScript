import "unicode.macro_export" as {
	$, -- import all macros
	$配置: $我的配置, -- rename macro $config to $myconfig
}

import "unicode.macro_todo" as $

$断言集 对象 == nil

$我的配置 false

结果 = $断言 对象 == nil

macro 和 = (...)->
	值们 = [元素 for 元素 in *{...}]
	$显示宏 "和", "#{ table.concat 值们, " and " }"

if $和 函数1!
	打印 "没问题"

if $和 函数1!, 函数2!, 函数3!
	打印 "没问题"

对象 = $复制(
	@
	{位置: {}, 标签: 标签::转数字!}
	标识
	连接们
	位置.x坐标
	位置.y坐标
	位置.z坐标
)

macro 在 = (目标, ...)->
	值们 = [元素 for 元素 in *{...}]
	$显示宏 "在", table.concat ["#{目标} == #{值}" for 值 in *值们], " or "

if 变量x |> $在 "🍎", "🐷", "🐶"
	打印 "存在"

macro 映射 = (数组, 动作)->
	$显示宏 "映射", "[#{动作} for _ in *#{数组}]"

macro 过滤 = (数组, 动作)->
	$显示宏 "过滤", "[_ for _ in *#{数组} when #{动作}]"

macro 合并 = (数组, 默认值, 动作)->
	$显示宏 "合并", "if ##{数组} == 0
	#{默认值}
else
	_1 = #{默认值}
	for _2 in *#{数组}
		_1 = #{动作}
	_1"

macro 每一个 = (数组, 动作)->
	$显示宏 "每一个", "for _ in *#{数组}
	#{动作}"

macro 管道 = (...)->
	switch select "#", ...
		when 0 then return ""
		when 1 then return ...
	操作数组 = {...}
	最后一个 = 操作数组[1]
	声明数组 = for 计数 = 2, #操作数组
		声明 = "\tlocal _#{计数} = #{最后一个} |> #{操作数组[计数]}"
		最后一个 = "_#{计数}"
		声明
	结果 = "do
#{table.concat 声明数组, "\n"}
	#{最后一个}"
	$显示宏 "管道", 结果

{1,2,3} |> $映射(_ * 2) |> $过滤(_ > 4) |> $每一个 打印 _

$每一个 $过滤($映射({1,2,3}, _ * 2), _ > 4), 打印 _

值 = $管道(
	{1, 2, 3}
	[[$映射(_ * 2)]]
	[[$过滤(_ > 4)]]
	[[$合并(0, _1 + _2)]]
)

macro 加 = (参数a, 参数b)-> "#{参数a} + #{参数b}"

$加(1,2)\调用 123

结果 = 1 |> $加 2

macro 柯里化 = (...)->
	参数数组 = {...}
	长度 = #参数数组
	主体 = 参数数组[长度]
	定义 = table.concat ["(#{参数数组[计数]})->" for 计数 = 1, 长度 - 1]
	"#{定义}\n#{主体\gsub "^do%s*\n",""}"

f = $柯里化 参数x,参数y,参数z,do
	打印 参数x,参数y,参数z

macro 获取里值 = (值)-> "do
	变量a = 1
	变量a + 1"

macro 获取里值_保持卫生 = (值)-> "(->
	local 变量a = 1
	变量a + 1)!"

do
	变量a = 8
	变量a = $获取里值!
	变量a += $获取里值!
	打印 变量a

do
	变量a = 8
	变量a = $获取里值_保持卫生!
	变量a += $获取里值_保持卫生!
	打印 变量a

macro Lua代码 = (代码)-> {
	code: 代码
	type: "lua"
}

变量x = 0

$Lua代码 [[
local function f(a)
	return a + 1
end
x = x + f(3)
]]

$Lua代码[[
function tb:func()
	print(123)
end
]]

打印 变量x

macro 定义函数 = (函数名, ...)->
	参数数组 = {...}
	最后一个 = table.remove 参数数组
	{
		code: $显示宏 "定义函数", "local function #{函数名}(#{table.concat 参数数组, ', '})
	#{最后一个}
end"
		type: "lua"
	}

sel = (参数a, 参数b, 参数c)-> if 参数a then 参数b else 参数c

$定义函数 sel, a, b, c, [[
	if a then
		return b
	else
		return c
	end
]]

$定义函数 dummy,[[]]

macro 插入注释 = (文本)-> {
	code: "-- #{文本\match '[\'"](.*)[\'"]'}"
	type: "lua"
}

$插入注释 "这有个注释"

import '下划线' as _

macro 链式调用 = (...)->
	主调用 = nil
	for 元素 in *{...}
		主调用 = 主调用? and "(#{主调用})\\#{元素}" or 元素
	$显示宏 "链式调用", 主调用

结果a = $链式调用(
	_{1, 2, 3, 4, -2, 3}
	链!
	映射 => @ * 2
	过滤 => @ > 3
	取值!
)

$链式调用(
	_{1, 2, 3, 4, -2, 3}
	链!
	映射 => @ * 2
	过滤 => @ > 3
	每一个 => 打印 @
)

结果 = $链式调用(
	原点.变换.根节点.游戏对象\父节点!
	后代!
	选择启用!
	选择可见!
	标签等于 "fx"
	其中 (x)-> x.名称\结尾为 "(克隆)"
	摧毁!
)

macro 链式调用B = (...)->
	switch select "#", ...
		when 0 then return ""
		when 1 then return ...
	参数数组 = {...}
	最后一个 = nil
	声明数组 = for 计数 = 1,#参数数组
		声明 = if 计数 == #参数数组
			最后的字符串 = 最后一个 and "#{最后一个}\\" or ""
			"\t#{最后的字符串}#{参数数组[计数]}"
		else
			最后的字符串 = 最后一个 and "#{最后一个}\\" or ""
			"\tlocal _#{计数} = #{最后的字符串}#{参数数组[计数]}"
		最后一个 = "_#{计数}"
		声明
	结果 = "do
#{table.concat 声明数组, '\n'}
"
	$显示宏 "链式调用B", 结果

$链式调用B(
	原点.变换.根节点.游戏对象\父节点!
	后代!
	选择启用!
	选择可见!
	标签等于 "fx"
	其中 (x)-> x.名称\结尾为 "(克隆)"
	摧毁!
)

macro 链式调用C = (...)->
	import "yue" as {:to_lua}
	主调用 = nil
	编译配置 = {
		implicit_return_root: false
		reserve_line_number: false
	}
	for 参数 in *{...}
		参数转代码 = to_lua(参数,编译配置)\gsub '%s*$',''
		if 主调用?
			主调用 = "#{主调用}:#{参数转代码}"
		else
			主调用 = 参数转代码
	{
		code: $显示宏 "链式调用C", 主调用
		type: "lua"
	}

$链式调用C(
	原点.变换.根节点.游戏对象\父节点!
	后代!
	选择启用!
	选择可见!
	标签等于 "fx"
	其中 (x)-> x.名称\结尾为 "(克隆)"
	摧毁!
)

macro 表 = -> "{'abc', 字段a:123, <call>:=> 998}"
打印 $表[1], $表.字段a, ($表)!, $表!

打印 "当前代码行数: #{ $LINE }"

$待办

macro 跳过 = -> ""

do
	打印 1
	<- $跳过
	打印 2
	打印 3

macro 跳过 = -> "while false do break"

_1 = ->
	打印 1
	<- $跳过
	打印 2
	打印 3

macro 隐式返回宏是允许的 = -> "打印 'abc'\n123"

$隐式返回宏是允许的

